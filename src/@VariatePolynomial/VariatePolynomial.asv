classdef VariatePolynomial < matlab.mixin.SetGetExactNames
    % Construct a variate polynomial
    
    properties

        P                   % struct containing the polynomial
        N                   % dimension of space over which polynomial is defined
        degree              % degree of polynomial
        
        Options = PolyOptions()
        CanonicalTrafo = false;
    end
    
    methods
        %% SET methods
        
        % set polynomial
        function set.P(obj,P)
            obj.P = P
        end
        
        
        %% GET methods
        function N = get.N(obj)
            
            N = [];
            while isempty(N)
                
            
        end
        
        function B = get.B(obj)
            if obj.order ==1
                
                if isempty(obj.B)
                    B = speye(obj.N,obj.N);
                else
                    B = obj.B;
                end
                
            elseif obj.order == 2
                
                B = [obj.C,    obj.M;
                    obj.M,  sparse(obj.n,obj.n)];
            end
        end
        
        function BinvA = get.BinvA(obj)
            BinvA = [sparse(obj.n,obj.n), speye(obj.n,obj.n)
                -obj.M\obj.K,   -obj.M\obj.C];
        end
        
        function F = get.F(obj)
            if obj.order == 1
                % First order input force in multi-index format
                F = obj.F;
            else
                switch obj.Options.notation
                    
                    case 'tensor'
                        d = length(obj.fnl) + 1;
                        F = cell(1,d);
                        F{1} = sptensor(obj.A);
                        
                        for j = 2:d
                            sizej = obj.N*ones(1,j+1);
                            if isempty(obj.fnl(j-1)) || isempty(obj.fnl(j-1).coeffs)
                                F{j} = sptensor(sizej);
                            else
                                [fnl_t] = multi_index_to_tensor(obj.fnl(j-1).coeffs,obj.fnl(j-1).ind);
                                subsj = fnl_t.subs;
                                valsj = -fnl_t.vals;
                                if obj.order==1
                                    valsj = -valsj;
                                end
                                F{j} = sptensor(subsj,valsj,sizej);
                            end
                        end
                        
                    case 'multiindex'
                        d = length(obj.fnl) + 1;
                        F = repmat(struct('coeffs',[],'ind',[]),1,d);
                        
                        for j = 2:d
                            if isempty(obj.fnl(j-1))
                                F(j) = [];
                                %% following elseif could be removed if inputs are always strictly either first
                                % or second order - not like in bernoulli beam
                            elseif size(obj.fnl(j-1).coeffs,1) == obj.N %fnl already 1st order form, i.e BernoulliBeam
                                F(j).coeffs = obj.fnl(j-1).coeffs;
                                F(j).ind    = obj.fnl(j-1).ind;
                                
                            else % conversion to 1st order form
                                F(j).coeffs = [-obj.fnl(j-1).coeffs;...
                                    sparse(obj.n, size(obj.fnl(j-1).coeffs,2)) ];
                                if obj.n == size(obj.fnl(j-1).ind,2) % No nonlinear damping
                                    F(j).ind = [obj.fnl(j-1).ind.';...
                                        sparse(obj.n, size(obj.fnl(j-1).ind,1)) ].';
                                else %Nonlinear damping
                                    F(j).ind = obj.fnl(j-1).ind;
                                end
                                
                            end
                        end
                        
                    otherwise
                        error('The option should be tensor or multiindex.');
                end
            end
        end
        
        function n = get.n(obj)
            n = length(obj.M);
        end
        
        function N = get.N(obj)
            N = length(obj.A);
        end
        
        function nKappa = get.nKappa(obj)
            nKappa = numel(obj.Fext.data);
        end
        
        function kappas = get.kappas(obj)
            %kappas stored in rows
            sz_kappa = size(obj.Fext.data(1).kappa,2);
            kappas = reshape([obj.Fext.data.kappa],sz_kappa,[]).';
            
        end
        
        function Fext = get.Fext(obj)
            if obj.order ==1
                Fext = obj.Fext;
            elseif obj.order == 2
                Fext.data    = set_Fext(obj);
                Fext.epsilon = obj.fext.epsilon;
            end
        end
        
        
        function degree = get.degree(obj)
            degree = 0;
            if ~isempty(obj.A)
                degree = length(obj.F);
            end
        end
        
        %% other methods
        
        [V, D, W] = linear_spectral_analysis(obj)
        
        function add_forcing(obj,f,varargin)
            if ~isfield(f, 'data') % new format
                switch obj.order
                    case 1
                        nn = size(f,1);
                        Kappas = varargin{1};
                        data(1).kappa = Kappas(1);
                        data(2).kappa = Kappas(2);
                        data(1).F_n_k(1).coeffs = f(:,1);
                        data(1).F_n_k(1).ind    = zeros(1,nn);
                        data(2).F_n_k(1).coeffs = f(:,2);
                        data(2).F_n_k(1).ind    = zeros(1,nn);
                        f_ext.data = data;
                    case 2
                        nn = size(f,1);
                        Kappas = varargin{1};
                        data(1).kappa = Kappas(1);
                        data(2).kappa = Kappas(2);
                        data(1).f_n_k(1).coeffs = f(:,1);
                        data(1).f_n_k(1).ind    = zeros(1,nn);
                        data(2).f_n_k(1).coeffs = f(:,2);
                        data(2).f_n_k(1).ind    = zeros(1,nn);
                        f_ext.data = data;
                end
                
                if numel(varargin)>1
                    f_ext.epsilon = varargin{2};
                else
                    f_ext.epsilon = 1;
                end
            else
                f_ext = f;
            end
            
            switch obj.order
                
                case 1
                    obj.Fext.data = f_ext.data;
                    
                    if isfield(f_ext,'epsilon')
                        obj.Fext.epsilon = f_ext.epsilon;
                        
                    elseif nargin == 3
                        obj.Fext.epsilon = varargin{1};
                        
                    else
                        obj.Fext.epsilon = 1;
                        
                    end
                    
                case 2
                    obj.fext.data = f_ext.data;
                    
                    if isfield(f_ext,'epsilon')
                        obj.fext.epsilon = f_ext.epsilon;
                        
                    elseif nargin == 3
                        obj.fext.epsilon = varargin{1};
                        
                    else
                        obj.fext.epsilon = 1;
                        
                    end
            end
        end
        
        
        fext = compute_fext(obj,t,x)
        Fext = evaluate_Fext(obj,t,z)
        fnl = compute_fnl(obj,x,xd)
        dfnl = compute_dfnldx(obj,x,xd)
        dfnl = compute_dfnldxd(obj,x,xd)
        Fnl = evaluate_Fnl(obj,z)
        f = odefun(obj,t,z)
        [r, drdqdd,drdqd,drdq, c0] = residual(obj, q, qd, qdd, t)
    end
end


function [fnl_multi]  = set_fnl(fnlTensor)
%Sets second order nonlinear force in multi-index format
d   = length(fnlTensor) + 1;

fnl_multi = repmat(struct('coeffs',[],'ind',[]),1,d-1);

for j = 2:d
    if isempty(fnlTensor{j-1}) || nnz(fnlTensor{j-1}) == 0
        
    else
        sizej = fnlTensor{j-1}.size;
        subsj = fnlTensor{j-1}.subs;
        valsj = fnlTensor{j-1}.vals;
        tmp = tensor_to_multi_index(sptensor(subsj,valsj,sizej));
        fnl_multi(j-1).coeffs = tmp.coeffs;
        fnl_multi(j-1).ind = tmp.ind;
    end
end
end

function [data] = set_Fext(obj)
% Creates the data struct from the input second order force
% Structs for storing the coefficients
F_n_k = repmat(struct('coeffs',[],'ind',[]),numel(obj.fext.data(1).f_n_k),1);
data  = repmat(struct('kappa',[],'F_n_k',[]),numel(obj.fext.data),1);

% Fill the structs
for i = 1:numel(obj.fext.data)
    for j = 1:numel(obj.fext.data(i).f_n_k)
        F_n_k(j).coeffs = [obj.fext.data(i).f_n_k(j).coeffs;...
            sparse(obj.n, size(obj.fext.data(i).f_n_k(j).coeffs,2)) ];
        F_n_k(j).ind = [obj.fext.data(i).f_n_k(j).ind.';...
            sparse(obj.n, size(obj.fext.data(i).f_n_k(j).ind,1)) ].';
    end
    data(i).F_n_k = F_n_k;
    data(i).kappa = obj.fext.data(i).kappa;
end
end